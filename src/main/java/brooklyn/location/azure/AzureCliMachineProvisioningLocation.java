package brooklyn.location.azure;

import static brooklyn.util.JavaGroovyEquivalents.groovyTruth;
import static com.google.common.base.Preconditions.checkNotNull;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import brooklyn.config.ConfigKey;
import brooklyn.entity.basic.ConfigKeys;
import brooklyn.location.LocationSpec;
import brooklyn.location.NoMachinesAvailableException;
import brooklyn.location.basic.SshMachineLocation;
import brooklyn.location.cloud.AbstractCloudMachineProvisioningLocation;
import brooklyn.location.cloud.CloudLocationConfig;
import brooklyn.location.cloud.CloudMachineNamer;
import brooklyn.management.ExecutionManager;
import brooklyn.util.config.ConfigBag;
import brooklyn.util.exceptions.Exceptions;
import brooklyn.util.flags.SetFromFlag;
import brooklyn.util.repeat.Repeater;
import brooklyn.util.task.system.ProcessTaskFactory;
import brooklyn.util.task.system.ProcessTaskWrapper;
import brooklyn.util.task.system.internal.SystemProcessTaskFactory.ConcreteSystemProcessTaskFactory;
import brooklyn.util.text.Strings;
import brooklyn.util.time.Time;

import com.google.common.base.Splitter;
import com.google.common.base.Stopwatch;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.util.concurrent.Callables;

/**
 * Rudimentary VM-provisioning mechanism for MS Azure.
 * 
 * Calls-out to the Azure command-line client, which must be installed on the local machine
 * and available on the current user's $PATH.
 */
public class AzureCliMachineProvisioningLocation extends AbstractCloudMachineProvisioningLocation implements CloudLocationConfig {

    private static final Logger LOG = LoggerFactory.getLogger(AzureCliMachineProvisioningLocation.class);
    
    private static final long serialVersionUID = 1L;

    private final Map<AzureSshMachineLocation,String> vmInstanceIds = Maps.newLinkedHashMap();
    private String binaryLocation; 

    @SetFromFlag("azureBinaryLocation")
    public static final ConfigKey<String> AZURE_BINARY_PATH = ConfigKeys.newStringConfigKey("azureBinaryLocation", "Location of the azure CLI script", "/usr/local/bin/azure");

    @SetFromFlag("azureUser")
    public static final ConfigKey<String> AZURE_USER = ConfigKeys.newStringConfigKey("azureUser", "Login name for newly-provisioned machine", "brooklyn");

    @SetFromFlag("azurePassword")
    public static final ConfigKey<String> AZURE_PASSWORD = ConfigKeys.newStringConfigKey("azurePassword", "Login password for newly-provisioned machine");

    @SetFromFlag("imageId")
    public static final ConfigKey<String> IMAGE_ID = ConfigKeys.newStringConfigKey("imageId", "Azure image id to use for provisioning VM");

    @SetFromFlag("machineSize")
    public static final ConfigKey<String> MACHINE_SIZE = ConfigKeys.newStringConfigKey("machineSize", "Azure VM size", "extrasmall");

    @SetFromFlag("vnet")
    public static final ConfigKey<String> VNET = ConfigKeys.newStringConfigKey("vnet", "Azure Virtual Network");

    @Override
    public void init() {
        super.init();
        binaryLocation = checkNotNull(getConfig(AZURE_BINARY_PATH), "azureBinaryPath");
    }

    /** returns the location ID used by the provider, if set, e.g. us-west-1 */
    public String getRegion() {
        return getConfig(CLOUD_REGION_ID);
    }

    protected <T> T getRequiredConfig(ConfigBag allconfig, ConfigKey<T> key) {
        return checkNotNull(allconfig.get(key), key.getName());
    }
    
    @SuppressWarnings({ "deprecation", "rawtypes" })
    @Override
    public AzureCliMachineProvisioningLocation configure(Map properties) {
        super.configure(properties);
        
        if (isDisplayNameAutoGenerated() || !groovyTruth(getDisplayName())) {
            // TODO would be nice if this took the spec name set
            setDisplayName(AzureLocationResolver.AZURE +
                   (!Strings.isBlank(getRegion()) ? ":"+getRegion() : ""));
        }
        return this;
    }

    @SuppressWarnings("unchecked")
    @Override
    public AzureSshMachineLocation obtain(Map<?, ?> flags) throws NoMachinesAvailableException {
        ConfigBag allconfig = ConfigBag.newInstanceExtending(getLocalConfigBag(), flags);

        String region = getRequiredConfig(allconfig, CLOUD_REGION_ID);
        String imageId = getRequiredConfig(allconfig, IMAGE_ID);
        String machineSize = getRequiredConfig(allconfig, MACHINE_SIZE);
        String vnet = allconfig.get(VNET);
        String vnetCmd = "";
        binaryLocation = getRequiredConfig(allconfig, AZURE_BINARY_PATH);
        allconfig.put(CloudLocationConfig.VM_NAME_MAX_LENGTH, 15);
        final String vmname = new CloudMachineNamer(allconfig).generateNewMachineUniqueName();
        String user = getRequiredConfig(allconfig, AZURE_USER);
        // TODO: Auto generate password that contains lower case, upper case, numeric and special character
        String password = getRequiredConfig(allconfig, AZURE_PASSWORD);

        // TODO: -e (ssh) for Unix, -r (RDP) for Windows
        if (vnet != null) vnetCmd = "-w " + vnet;
        String cmd = binaryLocation + " vm create -z " + machineSize + " " + vnetCmd + " -e -r -l \"" + region + "\" " + vmname + " " + imageId + " " + user + " " + password;
        ProcessTaskWrapper<?> result = exec("create-vm", cmd);
        if (result.getExitCode() != 0) {
            LOG.warn("Error starting VM: exitCode={}; stderr={}; stdout={}", new Object[] {result.getExitCode(), result.getStderr(), result.getStdout()});
            throw new IllegalStateException("Error starting VM in "+this+" (see log for details)");
        }

        // FIXME What is a sensible time to wait?
        Stopwatch timer = Stopwatch.createStarted();

        boolean isrunning = Repeater.create()
                .every(1, TimeUnit.SECONDS)
                .limitTimeTo(1, TimeUnit.HOURS)
                .repeat(Callables.returning(null))
                .until(new Callable<Boolean>() {
                        @Override public Boolean call() throws Exception {
                            return checkRunning(vmname);
                        }})
                .run();

        if (!isrunning) {
            throw new IllegalStateException("VM " + vmname + " in " + this + " not running after " + Time.makeTimeStringRounded(timer));
        } else {
            LOG.info("VM {} in {} running after {}", new Object[] {vmname, this, Time.makeTimeStringRounded(timer)});
        }

        // FIXME: Get os from azure vm image show fooimageid

        try {
            createEndpoints((Set<Integer>)flags.get("inboundPorts"), vmname);
            String dnsname = getVmProperty(vmname, "DNSName");
            String subnetdnsname = getVmProperty(vmname, "IPAddress");

            AzureSshMachineLocation machine = addChild(LocationSpec.create(AzureSshMachineLocation.class)
                    .configure(flags)
                    .configure("name", vmname)
                    .configure("address", dnsname)
                    .configure("subnetAddress", subnetdnsname)
                    .configure("user", user)
                    .configure("password", password));

            vmInstanceIds.put(machine, vmname);
            return machine;

        } catch (IOException e) {
            throw Exceptions.propagate(e);
        }
    }

    @Override
    public void release(SshMachineLocation machine) {
        String instanceId = vmInstanceIds.remove(machine);
        if (instanceId == null) {
            throw new IllegalArgumentException("Unknown machine "+machine);
        }

        LOG.info("Releasing machine {} in {}, instance id {}", new Object[] {machine, this, instanceId});

        removeChild(machine);
        try {
            releaseNode(instanceId);
        } catch (Exception e) {
            LOG.error("Problem releasing machine "+machine+" in "+this+", instance id "+instanceId+
                    "; discarding instance and continuing...", e);
            Exceptions.propagate(e);
        }
    }

    protected void releaseNode(String instanceId) {
        // NOTE: -q is required to suppress interactive confirmation!
        // NOTE: -b also cleans up attached disks (blobs) which is probably what we want
        String cmd = binaryLocation + " vm delete -bq " + instanceId;
        ProcessTaskWrapper<?> result = exec("delete-vm", cmd);
        if (result.getExitCode() != 0) {
            LOG.warn("Error deleting VM: exitCode={}; stderr={}; stdout={}", new Object[] {result.getExitCode(), result.getStderr(), result.getStdout()});
        }
    }

    private boolean checkRunning(String vmname) throws IOException {
        return getVmProperty(vmname, "InstanceStatus").equals("ReadyRole");
    }

    private String getVmProperty(String vmname, String propertyName) throws IOException {
        String cmd = binaryLocation + " vm show " + vmname;
        ProcessTaskWrapper<?> result = exec("show-vm", cmd);
        if (result.getExitCode() != 0) {
            LOG.warn("Error showing VM: exitCode={}; stderr={}; stdout={}", new Object[] {result.getExitCode(), result.getStderr(), result.getStdout()});
        }
        Iterable<String> lines = Splitter.on("\n").split(result.getStdout());
        for (String line : lines) {
            String prefix = "data:    " + propertyName;
            if (line.startsWith(prefix)) {
                return line.substring(prefix.length() + 2, line.length() - 1).trim();
            }
        }
        return null;
    }

    private void createEndpoints(Set<Integer> ports, String vmname) throws IOException {
        if (ports == null) return;
        for (Integer port : ports) {
            String cmd = binaryLocation + " vm endpoint create " + vmname + " " + port + " " + port;
            ProcessTaskWrapper<?> result = exec("create-endpoint", cmd);
            if (result.getExitCode() != 0) {
                LOG.warn("Error creating endpoint: exitCode={}; stderr={}; stdout={}", new Object[] {result.getExitCode(), result.getStderr(), result.getStdout()});
            }
        }
    }

    protected ProcessTaskWrapper<?> exec(String summary, String command) {
        return exec(summary, command, ImmutableMap.<String,String>of());
    }

    protected ProcessTaskWrapper<?> exec(String summary, String command, Map<String,String> env) {
        ProcessTaskFactory<Object> taskFactory = new ConcreteSystemProcessTaskFactory<Object>(command)
                .environmentVariables(env)
                //.loginShell(true)
                .runAsCommand()
                .summary(summary);

        ExecutionManager executionManager = super.getManagementContext().getExecutionManager();
        ProcessTaskWrapper<?> taskWrapper = taskFactory.newTask();
        executionManager.submit(taskWrapper);
        taskWrapper.block();
        return taskWrapper;
    }

}
